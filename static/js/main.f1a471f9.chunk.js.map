{"version":3,"sources":["../../node_modules/encoding/lib sync","lib/utils/private.ts","lib/utils/translate.ts","lib/utils/cacheClass.ts","lib/utils/index.ts","components/Translate.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","API_KEY","Cache","cache_","this","key","value","fetch","require","process","API","cache","make_request","lang","text","a","method","then","response","json","data","setCache","catch","error","message","translate","tryGetCache","console","log","translateText","TranslateUtils","TranslateInput","props","className","type","onClick","handleSetLang","onChange","handleChange","onKeyPress","handleSubmit","TranslateOuntput","Translate","state","langTo","textForTranstale","textTranslate","bind","event","preventDefault","setState","currentTarget","shiftKey","result","React","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.f1a471f9.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 121;","export const API_KEY = 'trnsl.1.1.20190503T141705Z.7e1cb280e23d6a08.185413112c5e3d0261abefb9c4b18b8bf9d8fdc8';","import { Cache } from './cacheClass';\nimport { IResponse, IResponseError } from './types';\nconst fetch = require('node-fetch');\n\n let API_KEY: string;\nif (process.env.API_KEY) {\n\tAPI_KEY = process.env.API_KEY\n} else {\n\tAPI_KEY = require('./private.ts').API_KEY;\n}\n\nconst API = 'https://translate.yandex.net/api/v1.5/tr.json/translate';\n\nlet cache = new Cache();\n\nasync function make_request(lang: string, text: string) : Promise<string> {\n\treturn fetch(`${API}?key=${API_KEY}&lang=${lang}&text=${text}`, { method: 'POST' })\n\t.then((response: Response) => response.json())\n\t.then((data: IResponse) => {\n\t\tcache.setCache(`${ text }::::${ lang }`, data.text);\n\t\treturn data.text;\n\t})\n\t.catch((error: IResponseError) => {\n\t\tcache.setCache(`${ text }::::${ lang }`, error.message);\n\t\treturn error.message;\n\t});\n}\n\nexport async function translate(text: string, lang: string): Promise<string> {\n\tconst value: null | string = cache.tryGetCache(`${ text }::::${ lang }`)\n\tif (value) {\n\t\tconsole.log('from cache');\n\t\treturn value;\n\t}\n\tlet translateText = await make_request(lang, text)\n\treturn translateText;\n};\n","interface ICache {\n\t[index: string] : string\n}\n\nexport class Cache {\n\tconstructor() {\n\t\tthis.cache_ = {}\n\t}\n\n\tsetCache(key: string, value: string) {\n\t\tthis.cache_[key] = value;\n\t}\n\n\ttryGetCache(key: string): string | null {\n\t\ttry {\n\t\t\treturn this.cache_[key];\n\t\t}\n\t\tcatch(e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclear() {\n\t\tthis.cache_ = {};\n\t}\n\n\tprivate cache_: ICache;\n}","import * as TranslateUtils from './translate';\n\nexport default TranslateUtils;","import * as React from 'react'\nimport TranslateUtils from '../lib/utils/index'\nimport '../App.css';\n\nfunction TranslateInput(props: {\n\thandleChange: ((event: React.ChangeEvent<HTMLTextAreaElement>) => void) | undefined, \n\thandleSubmit: ((event: React.KeyboardEvent<HTMLTextAreaElement>) => void) | undefined,\n\thandleSetLang: ((event: React.FormEvent<HTMLInputElement>) => void) | undefined\n}) {\n\treturn (\n\t\t<div className=\"transliteInput\">\n\t\t<form >\n\t\t\t<p className=\"headerBlock\">Выберите язык, в который хотите выполнить перевод:</p>\n\t\t\t<div className='langs'>\n\t\t\t\t<input type=\"button\" value='ru' className='button' onClick={props.handleSetLang} />\n\t\t\t\t<input type=\"button\" value=\"en\" className='button'onClick={props.handleSetLang}/>\n\t\t\t\t<input type=\"button\" value=\"es\" className='button' onClick={props.handleSetLang}/>\n\t\t\t\t<input type=\"button\" value=\"it\" className='button' onClick={props.handleSetLang}/>\n\t\t\t\t<input type=\"button\" value=\"zh\" className='button' onClick={props.handleSetLang}/>\n\t\t\t</div>\n\t\t\t<textarea className=\"input\" onChange={props.handleChange} onKeyPress={props.handleSubmit}/>\n\t\t</form>\n\t\t</div>\n\t);\n}\n\nfunction TranslateOuntput(props: {translateText: string, langTo: string}) {\n\treturn (\n\t\t<div className=\"transliteOutput\">\n\t\t\t<p className=\"headerBlock\">Перевод:</p>\n\t\t\t<div id=\"output\" >\n\t\t\t\t{props.translateText}\n\t\t\t</div>\n\t\t</div>\n\t);\n}\n\n\nclass Translate extends React.Component<{}, {langTo: string, textForTranstale: string, textTranslate: string}> {\n\tconstructor(props: {}){\n\t\tsuper(props);\n\n\t\tthis.handleChange = this.handleChange.bind(this);\n\t\tthis.handleSubmit = this.handleSubmit.bind(this);\n\t\tthis.handleSetLang = this.handleSetLang.bind(this);\n\t}\n\n\tstate = {\n\t\tlangTo: '',\n\t\ttextForTranstale: '',\n\t\ttextTranslate: ''\n\t}\n\n\thandleChange(event: React.FormEvent<HTMLTextAreaElement>) {\n\t\tevent.preventDefault();\n\t\tthis.setState({\n\t\t\ttextForTranstale: event.currentTarget.value\n\t\t})\n\t  }\n\t\n\t  async handleSubmit(event: React.KeyboardEvent<HTMLTextAreaElement>) {\n\t\tif (event.key === 'Enter' && !event.shiftKey) {\n\t\t\tevent.preventDefault();\n\n\t\t\t  const { textForTranstale, langTo } = this.state;\n\t\t\t  const result = await TranslateUtils.translate(textForTranstale, langTo);\n\t\t\t  this.setState({\n\t\t\t\ttextTranslate: result,\n\t\t\t  })\n\n\t  \t}\n\t}\n\n\t  handleSetLang(event: React.FormEvent<HTMLInputElement>) {\n\t\tevent.preventDefault();\n\t\tthis.setState({\n\t\t\tlangTo: event.currentTarget.value\n\t\t})\n\t  }\n\n\trender() {\n\t\treturn(\n\t\t\t<div className=\"container\">\n\t\t\t\t<TranslateInput handleChange={this.handleChange} handleSubmit={this.handleSubmit} handleSetLang={this.handleSetLang}/>\n\t\t\t\t<TranslateOuntput translateText={this.state.textTranslate} langTo={this.state.langTo}/>\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default Translate;","import React from 'react';\nimport './App.css';\nimport Translate from './components/Translate'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        TechnoTrack Translate\n      </header>\n      <Translate />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}